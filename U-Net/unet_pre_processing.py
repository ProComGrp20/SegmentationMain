# -*- coding: utf-8 -*-
"""UNET_Pre-processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13WinCXYhyoRDZgYeLlaRYjES3AP6kw8t
"""

# Youtube: https://www.youtube.com/watch?v=NJNvXEYa_gM

import os, glob
import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt
import cv2

from google.colab import drive
drive.mount('/content/gdrive/')

# STEP 1 - Load and visualize data
dataInputPath = '/content/gdrive/MyDrive/Projet_U_net/Test/'
imagePathInput = os.path.join(dataInputPath, 'Img/')
maskPathInput = os.path.join(dataInputPath, 'Mask/')

dataOutputPath = '/content/gdrive/MyDrive/Projet_U_net/Slices/'
imageSliceOutput = os.path.join(dataOutputPath, 'Img_test/')
maskSliceOutput = os.path.join(dataOutputPath, 'Mask_test/')

# STEP 2 - Image normalization
INTENSITY_MIN = 0
INTENSITY_MAX = 2000
INTENSITY_RANGE = INTENSITY_MAX - INTENSITY_MIN

# STEP 3 - Slicing and saving
SLICE_X = False
SLICE_Y = False
SLICE_Z = True

SLICE_DECIMATE_IDENTIFIER = 3

# Load image and see max min 
imgPath = os.path.join(imagePathInput, '21-T2SPIR-src.nii.gz')
img = nib.load(imgPath).get_fdata()
np.min(img), np.max(img), img.shape, type(img)

# Load image mask and see max min 
maskPath = os.path.join(maskPathInput, '21-T2SPIR-mask.nii.gz')
mask = nib.load(maskPath).get_fdata()
np.min(mask), np.max(mask), mask.shape, type(mask)

# Show image slice
imgPath = os.path.join(imagePathInput, '21-T2SPIR-src.nii.gz')
img = nib.load(imgPath).get_fdata()
imgSlice = img[:,:,15]
plt.hist(imgSlice.ravel(), bins=256, range=(200, 2000))
#plt.imshow(imgSlice)
plt.show()
print(np.max(imgSlice))

# Normalize image
def normalizeImageIntensityRange(img):
    img[img < INTENSITY_MIN] = INTENSITY_MIN
    img[img > INTENSITY_MAX] = INTENSITY_MAX
    return (img - INTENSITY_MIN) / INTENSITY_RANGE

nImg = normalizeImageIntensityRange(img)
np.min(nImg), np.max(nImg), nImg.shape, type(nImg), np.min(img), np.max(img)

# Read image or mask volume
def readImageVolume(imgPath, normalize=False):
    img = nib.load(imgPath).get_fdata()
    if normalize:
        return normalizeImageIntensityRange(img)
    else:
        return img

#readImageVolume(imgPath, normalize=False)
#readImageVolume(maskPath, normalize=False)

# Save volume slice to file
def saveSlice(img, fname, path):
    img = np.uint8(img * 255)
    fout = os.path.join(path, f'{fname}.png')
    cv2.imwrite(fout, img)
    print(f'[+] Slice saved: {fout}', end='\r')

def saveMSlice(mask, fname, path):
    mask = np.uint8(mask)
    fout = os.path.join(path, f'{fname}.png')
    cv2.imwrite(fout, mask)
    print(f'[+] Slice saved: {fout}', end='\r')

# Slice image in all directions and save
def sliceAndSaveVolumeImage(vol, fname, path):
    (dimx, dimy, dimz) = vol.shape
    print(dimx, dimy, dimz)
    cnt = 0
    if SLICE_X:
        cnt += dimx
        print('Slicing X: ')
        for i in range(dimx):
            saveSlice(vol[i,:,:], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_x', path)
            
    if SLICE_Y:
        cnt += dimy
        print('Slicing Y: ')
        for i in range(dimy):
            saveSlice(vol[:,i,:], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_y', path)
            
    if SLICE_Z:
        cnt += dimz
        print('Slicing Z: ')
        for i in range(dimz):
            saveSlice(vol[:,:,i], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_z', path)
    return cnt

def MsliceAndSaveVolumeImage(vol, fname, path):
    (dimx, dimy, dimz) = vol.shape
    print(dimx, dimy, dimz)
    cnt = 0
    if SLICE_X:
        cnt += dimx
        print('Slicing X: ')
        for i in range(dimx):
            saveMSlice(vol[i,:,:], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_x', path)
            
    if SLICE_Y:
        cnt += dimy
        print('Slicing Y: ')
        for i in range(dimy):
            saveMSlice(vol[:,i,:], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_y', path)
            
    if SLICE_Z:
        cnt += dimz
        print('Slicing Z: ')
        for i in range(dimz):
            saveMSlice(vol[:,:,i], fname+f'-slice{str(i).zfill(SLICE_DECIMATE_IDENTIFIER)}_z', path)
    return cnt

# Read and process image volumes
for index, filename in enumerate(sorted(glob.iglob(imagePathInput+'*.nii.gz'))):
    img = readImageVolume(filename, True)
    print(filename, img.shape, np.sum(img.shape), np.min(img), np.max(img))
    numOfSlices = sliceAndSaveVolumeImage(img, 'Test-'+str(index), imageSliceOutput)
    print(f'\n{filename}, {numOfSlices} slices created \n')

# Read and process image mask volumes
for index, filename in enumerate(sorted(glob.iglob(maskPathInput+'*.nii.gz'))):
    img = readImageVolume(filename, False)
    print(filename, img.shape, np.sum(img.shape), np.min(img), np.max(img))
    numOfSlices = MsliceAndSaveVolumeImage(img, 'Test-'+str(index), maskSliceOutput)
    print(f'\n{filename}, {numOfSlices} slices created \n')